%%{
# String literals with no interpolation.

machine Lexer;

include "definitions.csrl";

action EofLiteralError
{
    throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "unterminated string meets end of file");
}

action IsNested { Delimiter.IsNested }
action CanLabel { CanLabel }
action HasInterpolation { HasInterpolation }
action IsWords { IsWords }

action LabelDelimiter
{
    //# only ', " and ` can be used for labels

    Lexer.EmitStringContentToken(ts, te - 3);
    Lexer.EmitStringEndToken(te - 3, te - 1);
    Lexer.CurrentState = EndState;
    fhold;
    fbreak;
}

action Delimiter
{
    Delimiter.DecrementNesting();

    if(!Delimiter.IsNested)
    {
        Lexer.EmitStringContentToken(ts, te - 1);
        Lexer.EmitStringEndToken(te - 1, te);
        Lexer.CurrentState = EndState;

        if(Delimiter.CanJump && Lexer.LineJump > Lexer.Position)
        {
            fexec te = Lexer.LineJump;
            ts = Lexer.Position;
        }

        fbreak;
    }
}

action DelimiterEscape
{
    if(Delimiter.CanJump && Lexer.LineJump > Lexer.Position)
    {
        Lexer.EmitStringContentToken(ts, te);
        fexec te = Lexer.LineJump;
        ts = Lexer.Position;
    }
}

action NewLine
{
    if(Lexer.LineJump > Lexer.Position)
    {
        Lexer.EmitStringContentToken(ts, te);
        fexec te = Lexer.LineJump;
        ts = Lexer.Position;
    }
}

action NewLineEscape { throw new System.NotImplementedException("action NewLineEscape"); }

action WordSpace { throw new System.NotImplementedException("action WordSpace"); }


# ^D (0x4) isn't used by the lexer.
# The real string delimiter is replaced by ^D to generalize string content.

string_delimiter = 0x4;

word_space = space | '\n' @NewLine;

interpolation_escape = '\\' when HasInterpolation any+;


main := |*

	c_eof => EofLiteralError;

    # only ', " and ` can be used for labels
	string_delimiter when !IsNested ':' when CanLabel ^':' => { EmitLabelDelimiter(); fbreak; };

	string_delimiter when !IsNested => { EmitDelimiter(); fbreak; };

	string_delimiter when IsNested => { Delimiter.DecrementNesting(); };

	[\[{(<] => { Delimiter.IncrementNesting(); };

	word_space when IsWords word_space* => WordSpace;

	'\\' string_delimiter => DelimiterEscape;

	'\\' '\r'? '\n' => NewLineEscape;

	'\\\\';

	interpolation_escape & (char_escape - '\\' (string_delimiter | '\n' | '\\'));

    interpolation_escape & octal_escape;
    interpolation_escape & hex_escape;
    interpolation_escape & multi_unicode_escape;
    interpolation_escape & control_escape;

	'#' when HasInterpolation '{' => { EmitDBeg(); fbreak; };
	'#' when HasInterpolation '@@' name => { EmitDVar(tCVAR); };
	'#' when HasInterpolation '@' name => { EmitDVar(tIVAR); };
	'#' when HasInterpolation '$' ( gvar_char | name | '0' name_char* | '-' name_char ) => { EmitDVar(tGVAR); };
	'#' when HasInterpolation '$' [1-9] digit* => { EmitDVar(tNTH_REF); };
	'#' when HasInterpolation '$' back_ref_char => { EmitDVar(tBACK_REF); };

	any;

*|;

}%%
#pragma warning disable 162

using Mint.Parse;
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal partial class StringLiteral
    {
        public override void Advance()
        {
            Reset(%%{ write start; }%%);

            %% write exec noend;
        }

        %% write data nofinal noerror;
    }
}
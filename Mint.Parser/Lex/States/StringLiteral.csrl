%%{
# String literals with no interpolation.

machine Lexer;

include "definitions.csrl";

action EofLiteralError
{
    throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "unterminated string meets end of file");
}

action CanLabel { canLabel }

action StringDelimiter { throw new System.NotImplementedException("action StringDelimiter"); }

action StringDelimiterEscape { throw new System.NotImplementedException("action StringDelimiterEscape"); }

action StringNewLine { throw new System.NotImplementedException("action StringNewLine"); }


# ^D (0x4) isn't used by the lexer.
# The real string delimiter is replaced by ^D to generalize STRING_CONTENT.
string_delimiter = 0x4;


EXPR_STRING := |*

    c_eof => EofLiteralError;

    string_delimiter => StringDelimiter;

    '\\' string_delimiter => StringDelimiterEscape;

    '\n' => StringNewLine;

    any;

*|;

}%%
#pragma warning disable 162

using Mint.Parse;
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal partial class StringLiteral
    {
        public override void Advance()
        {
            Reset(%%{ write start; }%%);

            %% write exec noend;
        }

        %% write data nofinal noerror;
    }
}
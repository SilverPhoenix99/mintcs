%%{
# String literals with no interpolation.

machine Lexer;

include "definitions.csrl";

action EofLiteralError
{
    throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "unterminated string meets end of file");
}

action IsDelimiter { IsDelimiter }

action IsNested { Delimiter.IsNested }
action CanLabel { CanLabel }
action HasInterpolation { HasInterpolation }
action IsWords { IsWords }


action NewLine
{
    if(Lexer.LineJump > Lexer.Position)
    {
        EmitContentToken(te);
        fexec te = Lexer.LineJump;
        contentStart = ts = Lexer.Position;
    }
}

action LabelDelimiter
{
    //# only ', " and ` can be used for labels

    EmitContentToken(te - 3);
    EmitEndToken(te - 3, te - 1);
    Lexer.CurrentState = Lexer.BegState;
    Lexer.CanLabel = true;
    fhold;
    fbreak;
}

action Delimiter
{
    EmitContentToken(te - 1);

    if(IsRegexp)
    {
        contentStart = te - 1;
        fgoto REGEXP_END;
    }

    EmitEndToken(te - 1, te);
    Lexer.PopLiteral();
    Lexer.CurrentState = EndState;
    fbreak;

}

action WordSpace
{
    throw new System.NotImplementedException("action WordSpace");
}


string_nl = '\n' @NewLine;
string_any = any | string_nl;
string_delimiter = string_any when IsDelimiter;
string_space = space | string_nl;
interpolation_escape = '\\' when HasInterpolation any+;


main := |*

	c_eof => EofLiteralError;

    # only ', " and ` can be used for labels
	string_delimiter when !IsNested ':' when CanLabel ^':' => LabelDelimiter;

	string_delimiter when !IsNested => Delimiter;

    string_delimiter when IsNested => { Delimiter.DecrementNesting(); };

    [\[{(<] => { Delimiter.IncrementNesting(); };

	string_space when IsWords string_space* => WordSpace;

    # accepted escapes even without interpolation
	'\\' string_delimiter;
	'\\' '\r'? string_nl;
	'\\\\';

	interpolation_escape & (char_escape - '\\\\' - '\\\n');
    interpolation_escape & octal_escape;
    interpolation_escape & hex_escape;
    interpolation_escape & multi_unicode_escape;
    interpolation_escape & control_escape;

	'#' when HasInterpolation '{' => { EmitDBeg(); fbreak; };
	'#' when HasInterpolation '@@' name => { EmitDVar(tCVAR); fbreak; };
	'#' when HasInterpolation '@' name => { EmitDVar(tIVAR); fbreak; };
	'#' when HasInterpolation '$' ( gvar_char | name | '0' name_char* | '-' name_char ) => { EmitDVar(tGVAR); fbreak; };
	'#' when HasInterpolation '$' [1-9] digit* => { EmitDVar(tNTH_REF); fbreak; };
	'#' when HasInterpolation '$' back_ref_char => { EmitDVar(tBACK_REF); fbreak; };

	string_any;

*|;

REGEXP_END := |*
    (
          'm' @ { regexpOptions |= Multiline; }
        | 'i' @ { regexpOptions |= IgnoreCase; }
        | 'x' @ { regexpOptions |= Extend; }
        | 'o' @ { regexpOptions |= Once; }
        # accept the last encoding option
        | 'n' @ { regexpOptions = (regexpOptions & ~EncodingMask) | Ascii8; }
        | 'e' @ { regexpOptions = (regexpOptions & ~EncodingMask) | EucJp; }
        | 's' @ { regexpOptions = (regexpOptions & ~EncodingMask) | Windows31J; }
        | 'u' @ { regexpOptions = (regexpOptions & ~EncodingMask) | Utf8; }
    )+;

    ( alpha - [eimnosux] )+ => {
        var line = Lexer.LineAt(ts);
        var text = Lexer.TextAt(ts, te);
        var options = text.Length == 1 ? "option" : "options";
        throw new SyntaxError(Lexer.Filename, line, $"unknown regexp {options} - {text}");
    };

    ^alpha => {
        BeginToken.Properties["regexp_options"] = regexpOptions;
        EmitEndToken(contentStart, te - 1);
		Lexer.PopLiteral();
        Lexer.CurrentState = EndState;
        fhold;
        fbreak;
    };
*|;

}%%
#pragma warning disable 162

using Mint.Parse;
using static Mint.Lex.RegexpFlags;
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal partial class StringLiteral
    {
        public override void Advance()
        {
            Reset(%%{ write start; }%%);

            %% write exec noend;
        }

        %% write data nofinal noerror;
    }
}
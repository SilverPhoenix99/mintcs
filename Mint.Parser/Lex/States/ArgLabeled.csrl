%%{
# newline significant, +/- is an operator.  just after a label.

EXPR_ARG_LABELED := |*

    nl => {
        if(Lexer.InKwarg)
        {
            EmitToken(tNL, ts, ts + 1);
            Lexer.CommandStart = true;
            Lexer.CurrentState = Lexer.BegState;
            return null;
        }
    };

    ws+ '**' >TokStart ^ws => {
        EmitToken(tDSTAR, tokStart, tokStart + 2);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '**' => {
        EmitToken(tDSTAR, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    ws+ '*' >TokStart ^ws => {
        EmitToken(tSTAR, tokStart, tokStart + 1);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '*' => {
        EmitToken(tSTAR, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '!@' => {
        EmitToken(tNOT_OP, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '!=' => {
        EmitToken(tNEQ, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '!~' => {
        EmitToken(tNMATCH, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '!' => {
        EmitToken(tNOT_OP, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '===' => {
        EmitToken(tEQQ, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '==' => {
        EmitToken(tEQ, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '=~' => {
        EmitToken(tMATCH, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '=>' => {
        EmitToken(tASSOC, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '=' => {
        EmitToken(tASSIGN, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    any => {
        fhold;
        return Lexer.SharedState.Advance(this);
    };

*|;

}%%
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal partial class ArgLabeled
    {
        public override State Advance()
        {
            var ts = -1;
			var te = -1;
			var act = 0;
			var cs = Lexer_start;
			var pe = Lexer.Length;
			var eof = pe;

            %% write exec;

            return null;
        }

        %% write data;
    }
}
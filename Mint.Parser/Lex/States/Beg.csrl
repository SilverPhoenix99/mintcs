%%{
# ignore newline, +/- is a sign. can label.

machine Lexer;

include "definitions.csrl";

EXPR_BEG := |*

    '**' ^'=' => {
        Lexer.EmitToken(kDSTAR, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    };

    '*' ^'=' => {
        Lexer.EmitToken(kSTAR, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    };

    heredoc_identifier => {
        Lexer.EmitHeredocToken(ts, te);
        fbreak;
    };

    '&' ^[=&.] => {
        Lexer.EmitToken(kAMPER, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    };

    '+' integer_number => {
        Lexer.EmitIntegerToken(ts, te, numBase, isRational, isImaginary);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    '+' float_number => {
        Lexer.EmitFloatToken(ts, te, isRational, isImaginary);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    '+' ^'=' => {
        Lexer.EmitToken(kUPLUS, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    };

    '-' digit => {
        Lexer.EmitToken(kUMINUS_NUM, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    };

    '-' ^(ws_nl | [=>]) => {
        Lexer.EmitToken(kUMINUS, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    };

    '::' => {
        Lexer.EmitToken(kCOLON3, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    '/' => {
        Lexer.EmitStringToken(ts, te);
        fbreak;
    };

    '(' => {
        Lexer.EmitToken(kLPAREN, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CanLabel = true;
        Lexer.ParenNest++;
        Lexer.Cond.Push(false);
        Lexer.Cmdarg.Push(false);
        fbreak;
    };

    '[' => {
        Lexer.EmitToken(kLBRACK, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CanLabel = true;
        Lexer.ParenNest++;
        Lexer.Cond.Push(false);
        Lexer.Cmdarg.Push(false);
        fbreak;
    };

    '%' [Qqxr] (ascii - alnum) => {
        Lexer.EmitStringToken(ts, te);
        fbreak;
    };

    '%s' (ascii - alnum) => {
        Lexer.EmitStringToken(ts, te);
        Lexer.CurrentState = Lexer.FnameFitemState;
        fbreak;
    };

    '%' [WwIi] (ascii - alnum) ws_nl* => {
        Lexer.EmitStringToken(ts, ts + 3);
        fbreak;
    };

    '%' (ascii - alnum) => {
        Lexer.EmitStringToken(ts, te);
        fbreak;
    };

    '%' [QqWwIixrs]? c_eof => {
        var line = Lexer.LocationFor(ts, 0).StartLine;
        throw new SyntaxError(Lexer.Filename, line, "unterminated quoted string meets end of file");
    };

    '%' [QqWwIixrs]? (unicode | alnum) => {
        var line = Lexer.LocationFor(ts, 0).StartLine;
        throw new SyntaxError(Lexer.Filename, line, "unknown type of %string");
    };

    'if' => {
        Lexer.EmitToken(kIF, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CommandStart = true;
        fbreak;
    };

    'unless' => {
        Lexer.EmitToken(kUNLESS, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CommandStart = true;
        fbreak;
    };

    'until' => {
        Lexer.EmitToken(kUNTIL, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CommandStart = true;
        fbreak;
    };

    'while' => {
        Lexer.EmitToken(kWHILE, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CommandStart = true;
        fbreak;
    };

    'rescue' => {
        Lexer.EmitToken(kRESCUE, ts, te);
        Lexer.CurrentState = Lexer.MidState;
        fbreak;
    };

    'do' => {
        var tokenType = kDO_BLOCK;

        if(Lexer.LeftParenCounter > 0 && Lexer.LeftParenCounter == Lexer.ParenNest)
        {
            Lexer.LeftParenCounter = 0;
            Lexer.ParenNest--;
            tokenType = kDO_LAMBDA;
        }
        else if(Lexer.Cond.Peek)
        {
            tokenType = kDO_COND;
        }

        Lexer.EmitToken(tokenType, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CommandStart = true;
        fbreak;
    };

    any => CallSharedState;

*|;

}%%
#pragma warning disable 162

using Mint.Parse;
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal class Beg : Shared
    {
        protected override bool CanLabel => Lexer.CanLabel && !Lexer.CommandStart;

        public Beg(Lexer lexer) : base(lexer)
        { }

        protected override void EmitIdentifierToken()
        {
            var token = Lexer.EmitToken(tIDENTIFIER, ts, te);
            var isLocalVar = Lexer.IsVariableDefined(token.Value);
            if(isLocalVar)
            {
                Lexer.CurrentState = Lexer.EndState;
                Lexer.CanLabel = true;
            }
            else
            {
                Lexer.CurrentState = Lexer.CommandStart ? Lexer.CmdargState : Lexer.ArgState;
            }
        }

        protected override void EmitFidToken()
        {
            Lexer.EmitToken(tFID, ts, te - 1);
            Lexer.CurrentState = Lexer.CommandStart ? Lexer.CmdargState : Lexer.ArgState;
        }

        public override void Advance()
        {
            Reset(%%{ write start; }%%);

            %% write exec noend;
        }

        %% write data nofinal noerror;
    }
}
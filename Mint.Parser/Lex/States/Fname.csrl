%%{
# ignore newline, no reserved words.

machine Lexer;

include "definitions.csrl";

EXPR_FNAME := |*

    '!@' => {
        Lexer.EmitToken(kNOTOP, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        fbreak;
    };

    heredoc_identifier => {
        Lexer.EmitHeredocToken(ts, te);
        fbreak;
    };

    '`' => {
        Lexer.EmitToken(kBACKTICK, ts, te);
        Lexer.CurrentState = Lexer.EndfnState;
        fbreak;
    };

    '&' ^[=&.] => {
        Lexer.EmitToken(kAMPER, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        fbreak;
    };

    '|' ^[=|] => {
        Lexer.EmitToken(kPIPE, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        fbreak;
    };

    '+@' => {
        Lexer.EmitToken(kUPLUS, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        fbreak;
    };

    '-@' => {
        Lexer.EmitToken(kUMINUS, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        fbreak;
    };

    '~' '@'? => {
        Lexer.EmitToken(kNEG, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        fbreak;
    };

    '[]=' => {
        Lexer.EmitToken(kASET, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        fbreak;
    };

    '[]' => {
        Lexer.EmitToken(kAREF, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        fbreak;
    };

    '[' => {
        Lexer.EmitToken(kLBRACK2, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        Lexer.CanLabel = true;
        Lexer.ParenNest++;
        fbreak;
    };

    '$' [1-9] digit* => {
        Lexer.EmitToken(tGVAR, ts, te);
        Lexer.CurrentState = Lexer.EndState;
        fbreak;
    };

    '$' back_ref_char => {
        Lexer.EmitToken(tGVAR, ts, te);
        Lexer.CurrentState = Lexer.EndState;
        fbreak;
    };

    '%' ^'=' => {
        Lexer.EmitToken(kPERCENT, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    };

    name '=' ^[=~>] => {
        Lexer.EmitToken(tIDENTIFIER, ts, te - 1);
        Lexer.CurrentState = Lexer.EndfnState;
        fhold;
        fbreak;
    };

    name '==>' =>  {
        Lexer.EmitToken(tIDENTIFIER, ts, te - 2);
        Lexer.CurrentState = Lexer.EndfnState;
        fexec te - 2;
        fbreak;
    };

    constant - reserved => {
        Lexer.EmitToken(tCONSTANT, ts, te);
        Lexer.CurrentState = Lexer.EndfnState;
        fbreak;
    };

    'and' => {
        Lexer.EmitToken(kAND, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'begin' => {
        Lexer.EmitToken(kBEGIN, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'case' => {
        Lexer.EmitToken(kCASE, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'else' => {
        Lexer.EmitToken(kELSE, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'elsif' => {
        Lexer.EmitToken(kELSIF, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'ensure' => {
        Lexer.EmitToken(kENSURE, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'for' => {
        Lexer.EmitToken(kFOR, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'if' => {
        Lexer.EmitToken(kIF, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'in' => {
        Lexer.EmitToken(kIN, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'module' => {
        Lexer.EmitToken(kMODULE, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'or' => {
        Lexer.EmitToken(kOR, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'then' => {
        Lexer.EmitToken(kTHEN, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'unless' => {
        Lexer.EmitToken(kUNLESS, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'until' => {
        Lexer.EmitToken(kUNTIL, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'when' => {
        Lexer.EmitToken(kWHEN, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'while' => {
        Lexer.EmitToken(kWHILE, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    'rescue' => {
        Lexer.EmitToken(kRESCUE, ts, te);
        Lexer.CurrentState = Lexer.MidState;
        fbreak;
    };

    'do' => {
        Lexer.EmitToken(kDO, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    any => CallSharedState;

*|;

}%%
#pragma warning disable 162

using Mint.Parse;
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal class Fname : StateBase
    {
        public override State OperatorState => Lexer.ArgState;

        protected override int InitialState => %%{ write start; }%%;

        public Fname(Lexer lexer) : base(lexer)
        { }

        public override void EmitIdentifierToken(int ts, int te)
        {
            Lexer.EmitToken(tIDENTIFIER, ts, te);
            Lexer.CurrentState = Lexer.EndfnState;
        }

        public override void EmitFidToken(int ts, int te)
        {
            Lexer.EmitToken(tFID, ts, te);
            Lexer.CurrentState = Lexer.EndfnState;
        }

        protected override void InternalAdvance()
        {
            %% write exec noend;
        }

        %% write data nofinal noerror;
    }
}
%%{
# newline significant, +/- is an operator.

machine Lexer;

include "definitions.csrl";

EXPR_ARG := |*

    nl ws* ('&.' | '.' ^'.') => {
        fexec te - 2;
    };

    nl => {
        Lexer.EmitToken(kNL, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CommandStart = true;
        return null;
    };

    esc_ws_nl+ '**' ^(ws_nl | '=') => {
        Lexer.EmitToken(kDSTAR, te - 3, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    esc_ws_nl+ '*' ^(ws_nl | '=') => {
        Lexer.EmitToken(kSTAR, te - 2, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    esc_ws_nl+ %TokStart heredoc_identifier => {
        Lexer.EmitHeredocToken(tokStart, te);
        return null;
    };

    [''""] => {
        Lexer.EmitLabelableStringToken(ts, te);
        return null;
    };

    esc_ws_nl+ '&' ^(ws_nl | [=&.]) => {
        Lexer.EmitToken(kAMPER, te - 2, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    esc_ws_nl+ %TokStart '+' integer_number => {
        Lexer.EmitIntegerToken(tokStart, te, numBase, isRational, isImaginary);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    esc_ws_nl+ %TokStart '+' float_number => {
        Lexer.EmitFloatToken(tokStart, te, isRational, isImaginary);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    esc_ws_nl+ '+' ^(ws_nl | '=') => {
        Lexer.EmitToken(kUPLUS, te - 2, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    esc_ws_nl+ '-' digit => {
        Lexer.EmitToken(kUMINUS_NUM, te - 2, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    esc_ws_nl+ '-' ^(ws_nl | digit | [=>]) => {
        Lexer.EmitToken(kUMINUS, te - 2, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    esc_ws_nl+ '::' => {
        Lexer.EmitToken(kCOLON3, te - 2, te);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    esc_ws_nl+ '/' ^(ws_nl | '=') => {
        Lexer.EmitStringToken(te - 2, te - 1);
        fhold;
        return null;
    };

    esc_ws_nl+ '(' => {
        Lexer.EmitToken(kLPAREN_ARG, te - 1, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CanLabel = true;
        Lexer.ParenNest++;
        Lexer.Cond.Push(false);
        Lexer.Cmdarg.Push(false);
        return null;
    };

    esc_ws_nl+ '[' => {
        Lexer.EmitToken(kLBRACK, te - 1, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CanLabel = true;
        Lexer.ParenNest++;
        Lexer.Cond.Push(false);
        Lexer.Cmdarg.Push(false);
        return null;
    };

    '{' => {
        TokenType tokenType;
        if(Lexer.LeftParenCounter > 0 && Lexer.LeftParenCounter == Lexer.ParenNest)
        {
            tokenType = kLAMBEG;
            Lexer.LeftParenCounter = 0;
            Lexer.ParenNest--;
        }
        else
        {
            tokenType = kLBRACE2;
            Lexer.CanLabel = true;
            Lexer.CommandStart = true;
        }
        Lexer.EmitToken(tokenType, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.IncrementBraceNest();
        Lexer.Cond.Push(false);
        Lexer.Cmdarg.Push(false);
        return null;
    };

    esc_ws_nl+ '%' [Qqxr] (ascii - alnum) => {
        Lexer.EmitStringToken(te - 3, te);
        return null;
    };

    esc_ws_nl+ '%s' (ascii - alnum) => {
        Lexer.EmitStringToken(te - 3, te);
        Lexer.CurrentState = Lexer.FnameFitemState;
        return null;
    };

    esc_ws_nl+ %TokStart '%' [WwIi] (ascii - alnum) ws_nl* => {
        Lexer.EmitStringToken(tokStart, tokStart + 3);
        return null;
    };

    esc_ws_nl+ '%' (ascii - alnum - ws_nl - '=') => {
        Lexer.EmitStringToken(te - 2, te);
        return null;
    };

    esc_ws_nl+ '%' [QqWwIixrs]? c_eof => {
        var line = Lexer.LocationFor(ts, 0).StartLine;
        throw new SyntaxError(Lexer.Filename, line, "unterminated quoted string meets end of file");
    };

    esc_ws_nl+ '%' [QqWwIixrs]? (unicode | alnum) => {
        var line = Lexer.LocationFor(ts, 0).StartLine;
        throw new SyntaxError(Lexer.Filename, line, "unknown type of %string");
    };

    '?' ws_nl => {
        Lexer.EmitToken(kQMARK, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    any => {
        fhold;
        return Lexer.SharedState.Advance(this);
    };

*|;

}%%
#pragma warning disable 162

using Mint.Parse;
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal class Arg : StateBase
    {
        public Arg(Lexer lexer) : base(lexer)
        { }

        public override State Advance(State caller)
        {
            Reset(%%{ write start; }%%);

            %% write exec noend;

            return null;
        }

        %% write data nofinal noerror;
    }
}
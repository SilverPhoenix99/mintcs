%%{
# newline significant, +/- is an operator., and unbound braces. can label.

machine Lexer;

include "definitions.csrl";

EXPR_ENDFN := |*

    [''""] => {
        if(Lexer.CommandStart)
        {
            Lexer.EmitStringToken(ts, te);
        }
        else
        {
            Lexer.EmitLabelableStringToken(ts, te);
        }
        fbreak;
    };

    any => CallBaseState;

*|;

}%%
#pragma warning disable 162

using Mint.Parse;
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal class Endfn : End
    {
        protected override bool CanLabel => !Lexer.CommandStart;

        public Endfn(Lexer lexer) : base(lexer)
        { }

        protected override void EmitIdentifierToken()
        {
            var token = Lexer.EmitToken(tIDENTIFIER, ts, te);
            var isLocalVar = Lexer.IsVariableDefined(token.Value);
            if(isLocalVar)
            {
                Lexer.CurrentState = Lexer.EndState;
                Lexer.CanLabel = true;
            }
            else
            {
                Lexer.CurrentState = Lexer.CommandStart ? Lexer.CmdargState : Lexer.ArgState;
            }
        }

        public override void Advance()
        {
            Reset(%%{ write start; }%%);

            %% write exec noend;
        }

        %% write data nofinal noerror;
    }
}
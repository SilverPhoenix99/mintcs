%%{
# newline significant, +/- is an operator., and unbound braces.

machine Lexer;

include "definitions.csrl";

EXPR_ENDFN := |*

    nl ws* ('&.' | '.' ^'.') => {
        fexec te - 2;
    };

    nl => {
        Lexer.EmitToken(kNL, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.CommandStart = true;
        fbreak;
    };

    [''""] => {
        if(commandStart)
        {
            Lexer.EmitStringToken(ts, te);
        }
        else
        {
            Lexer.EmitLabelableStringToken(ts, te);
        }
        fbreak;
    };

    ':' ^':' => {
        Lexer.EmitToken(kCOLON, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    };

    '{' => {
        TokenType tokenType;
        if(Lexer.LeftParenCounter > 0 && Lexer.LeftParenCounter == Lexer.ParenNest)
        {
            tokenType = kLAMBEG;
            Lexer.LeftParenCounter = 0;
            Lexer.ParenNest--;
        }
        else
        {
            tokenType = kLBRACE2;
            Lexer.CanLabel = true;
            Lexer.CommandStart = true;
        }
        Lexer.EmitToken(tokenType, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        Lexer.IncrementBraceCount();
        Lexer.Cond.Push(false);
        Lexer.Cmdarg.Push(false);
        fbreak;
    };

    '?' => {
        Lexer.EmitToken(kQMARK, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    };

    any => CallSharedState;

*|;

}%%
#pragma warning disable 162

using Mint.Parse;
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal class Endfn : StateBase
    {
        public Endfn(Lexer lexer) : base(lexer)
        { }

        public override void Advance(State caller)
        {
            Reset(%%{ write start; }%%);

            %% write exec noend;
        }

        %% write data nofinal noerror;
    }
}
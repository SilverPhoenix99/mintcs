%%{
# newline significant, +/- is an operator.

machine Lexer;

include "definitions.csrl";

EXPR_CMDARG := |*

    nl ws_nl* ('&.' | '.' ^'.') => {
        fexec te - 2;
    };

    nl ws_nl* => {
        Lexer.EmitToken(kNL, ts, ts + 1);
        Lexer.CommandStart = true;
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    ws+ '**' ^(ws |  '=') => {
        Lexer.EmitToken(kDSTAR, te - 3, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    '**' ^'=' => {
        Lexer.EmitToken(kPOW, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    ws+ '*' ^(ws |  '=') => {
        Lexer.EmitToken(kSTAR, te - 2, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    '*' ^'=' => {
        Lexer.EmitToken(kMUL, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    '!@' => {
        Lexer.EmitToken(kNOTOP, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '!=' => {
        Lexer.EmitToken(kNEQ, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '!~' => {
        Lexer.EmitToken(kNMATCH, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '!' => {
        Lexer.EmitToken(kNOTOP, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '===' => {
        Lexer.EmitToken(kEQQ, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '==' => {
        Lexer.EmitToken(kEQ, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '=~' => {
        Lexer.EmitToken(kMATCH, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '=>' => {
        Lexer.EmitToken(kASSOC, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '=' => {
        Lexer.EmitToken(kASSIGN, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    ws+ %TokStart heredoc_identifier => {
        Lexer.EmitHeredocToken(tokStart, te);
        return null;
    };

    '<=>' => {
        Lexer.EmitToken(kCMP, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '<=' => {
        Lexer.EmitToken(kLEQ, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '<<' ^'=' => {
        Lexer.EmitToken(kLSHIFT, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    '<' => {
        Lexer.EmitToken(kLESS, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '>=' => {
        Lexer.EmitToken(kGEQ, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    '>>' ^'=' => {
        Lexer.EmitToken(kRSHIFT, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    '>' => {
        Lexer.EmitToken(kGREATER, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

    [''""] => {
        Lexer.EmitLabelableStringToken(ts, te);
        return null;
    };

    '`' => {
        Lexer.EmitStringToken(ts, te);
        return null;
    };

    any => {
        fhold;
        return Lexer.SharedState.Advance(this);
    };

*|;

}%%
#pragma warning disable 162

using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal class Cmdarg : StateBase
    {
        public Cmdarg(Lexer lexer) : base(lexer)
        { }

        public override State Advance()
        {
            var ts = -1;
			var te = -1;
			var act = 0;
			var cs = Lexer_start;
			var pe = Lexer.Length;
			var eof = pe;
            var tokStart = -1;
            var tokEnd = -1;
            var commandStart = Lexer.CommandStart;

            %% write exec;

            return null;
        }

        %% write data;
    }
}
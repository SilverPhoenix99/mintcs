%%{
# Expressions shared by all other states

machine Lexer;

include "definitions.csrl";

action EmbeddedDocEof
{
    throw new SyntaxError(Lexer.Filename, Lexer.CurrentLine, "embedded document meets end of file");
}

comment = '#' ^nl_eof* nl_eof;

embedded_doc =
    nl '=begin' (ws ^nl*)? nl
    (
        (any* nl)*
        :>>
        '=end' (ws ^nl*)? nl_eof
    ) @err(EmbeddedDocEof)
;

EXPR_SHARED := |*

	c_eof => { return null; };

    ws+ => { return caller; };

    comment => { fhold; return caller; };

    embedded_doc =>{ fhold; return caller; };

      '**='
    | '*='
    | '<<='
    | '>>='
    => {
        Lexer.EmitToken(tOP_ASGN, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        return null;
    };

*|;


}%%
#pragma warning disable 162

using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal partial class Shared
    {
        public State Advance(State caller)
        {
            var ts = -1;
			var te = -1;
			var act = 0;
			var cs = Lexer_start;
			var pe = Lexer.Length;
			var eof = pe;
            var tokStart = -1;
            var tokEnd = -1;
            var commandStart = Lexer.CommandStart;

            %% write exec;

            return null;
        }

        %% write data;
    }
}
%%{
# ignore newline, no reserved words. symbol literal as FNAME.

machine Lexer;

include "definitions.csrl";

EXPR_FNAME_FITEM := |*

    '**' ^'=' => {
        Lexer.EmitToken(kPOW, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        return null;
    };

    '*' ^'=' => {
        Lexer.EmitToken(kMUL, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        return null;
    };

    '!@' => {
        Lexer.EmitToken(kNOTOP, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '!=' => {
        Lexer.EmitToken(kNEQ, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '!~' => {
        Lexer.EmitToken(kNMATCH, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '!' => {
        Lexer.EmitToken(kNOTOP, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '===' => {
        Lexer.EmitToken(kEQQ, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '==' => {
        Lexer.EmitToken(kEQ, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '=~' => {
        Lexer.EmitToken(kMATCH, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '=>' => {
        Lexer.EmitToken(kASSOC, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '=' => {
        Lexer.EmitToken(kASSIGN, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    heredoc_identifier => {
        Lexer.EmitHeredocToken(ts, te);
        return null;
    };

    '<=>' => {
        Lexer.EmitToken(kCMP, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '<=' => {
        Lexer.EmitToken(kLEQ, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '<<' ^'=' => {
        Lexer.EmitToken(kLSHIFT, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        return null;
    };

    '<' => {
        Lexer.EmitToken(kLESS, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '>=' => {
        Lexer.EmitToken(kGEQ, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '>>' ^'=' => {
        Lexer.EmitToken(kRSHIFT, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        return null;
    };

    '>' => {
        Lexer.EmitToken(kGREATER, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '`' => {
        Lexer.EmitToken(kBACKTICK, ts, te);
        Lexer.CurrentState = Lexer.EndfnState;
        return null;
    };

    '&' ^[=&.] => {
        Lexer.EmitToken(kAMPER, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        return null;
    };

    '|' ^[=|] => {
        Lexer.EmitToken(kPIPE, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        return null;
    };

    '+@' => {
        Lexer.EmitToken(kUPLUS, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '+' => {
        Lexer.EmitToken(kPLUS, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '-@' => {
        Lexer.EmitToken(kUMINUS, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '-' => {
        Lexer.EmitToken(kMINUS, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '/' ^'=' => {
        Lexer.EmitToken(kDIV, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        return null;
    };

    '^' ^'=' => {
        Lexer.EmitToken(kXOR, ts, te - 1);
        Lexer.CurrentState = Lexer.ArgState;
        fhold;
        return null;
    };

    '~' '@'? => {
        Lexer.EmitToken(kNEG, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '[]=' => {
        Lexer.EmitToken(kASET, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '[]' => {
        Lexer.EmitToken(kAREF, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        return null;
    };

    '[' => {
        Lexer.EmitToken(kLBRACK2, ts, te);
        Lexer.CurrentState = Lexer.ArgState;
        Lexer.CanLabel = true;
        Lexer.ParenNest++;
        return null;
    };

    '$' [1-9] digit* => {
        Lexer.EmitToken(tGVAR, ts, te);
        Lexer.CurrentState = Lexer.EndState;
        return null;
    };

    '$' back_ref_char => {
        Lexer.EmitToken(tGVAR, ts, te);
        Lexer.CurrentState = Lexer.EndState;
        return null;
    };

    '%' ^'=' => {
        Lexer.EmitToken(kPERCENT, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        return null;
    };

    '%s' (ascii - alnum) => {
        Lexer.EmitStringToken(ts, te);
        Lexer.CurrentState = Lexer.FnameFitemState;
        return null;
    };

    any => {
        fhold;
        return Lexer.SharedState.Advance(this);
    };

*|;

}%%
#pragma warning disable 162

using Mint.Parse;
using static Mint.Parse.TokenType;

namespace Mint.Lex.States
{
    internal class FnameFitem : StateBase
    {
        public FnameFitem(Lexer lexer) : base(lexer)
        { }

        public override State Advance(State caller)
        {
            Reset(%%{ write start; }%%);

            %% write exec noend;

            return null;
        }

        %% write data nofinal noerror;
    }
}
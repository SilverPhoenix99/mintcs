%%{

# Character classes are in lowercase. e.g.: eof
# Machines/scanners are in uppercase. e.g.: EXPR_BEG
# Actions are in CamelCase. e.g.: DoEof

machine Lexer;

getkey CurrentChar;
variable p Lexer.Position;


### Shared Definitions

action TokStart
{
    tokStart = Lexer.Position;
}

action LineJump
{
    if(Lexer.LineJump > Lexer.Position)
    {
        fexec te = Lexer.LineJump;
        ts = Lexer.Position;
    }
}

action CallBaseState
{
    base.Advance();
    return;
}

c_eof = 0;
nl = '\n' @LineJump;
nl_eof = nl | c_eof;

ws = space - nl;
ws_nl = ws | nl;
esc_ws = ws | '\\' nl;
esc_ws_nl = esc_ws | nl;

unicode = ^ascii;
name_prefix = alpha | '_' | unicode;
name_char = name_prefix | digit;
back_ref_char = [&`''+];
gvar_char = [~*$?!@/\\;,.=:<>""];
comment = '#' ^nl_eof*;


### Heredoc identifier

action UnterminatedHeredocIdentifier
{
    throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "unterminated here document identifier");
}

heredoc_identifier = '<<' [~\-]? (
    name_char+
  | '"' ^('"' | nl_eof)* '"' @lerr(UnterminatedHeredocIdentifier)
  | "'" ^("'" | nl_eof)* "'" @lerr(UnterminatedHeredocIdentifier)
  | '`' ^('`' | nl_eof)* '`' @lerr(UnterminatedHeredocIdentifier)
);


### Numbers

action RationalSuffix
{
    isRational = true;
}

action ImaginarySuffix
{
    isImaginary = true;
}

action TrailError
{
    throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "trailing `_' in number");
}

bdigit = [01];
odigit = [0-7];

# digits with leading `_' like in 1_000_00
ubdigits = bdigit ( '_'? bdigit )* ('_' %TrailError)? ;
uodigits = odigit ( '_'? odigit )* ('_' %TrailError)? ;
uddigits =  digit ( '_'?  digit )* ('_' %TrailError)? ;
uxdigits = xdigit ( '_'? xdigit )* ('_' %TrailError)? ;

bin_number  =   '0' [bB]   ubdigits % { numBase =  2; };
oct_number  =   '0' [oO_]? uodigits % { numBase =  8; };
dec_number  =   '0' [dD]   uddigits % { numBase = 10; };
hex_number  =   '0' [xX]   uxdigits % { numBase = 16; };
int_number  = ( '0' | [1-9] ( '_'? digit )* ) ('_' %TrailError)? % { numBase = 10; };

# TODO: error => numeric literal without digits

integer_number = (
      bin_number
    | oct_number
    | dec_number
    | hex_number
    | int_number
) ('r' >RationalSuffix)? ('i' >ImaginarySuffix)? ;

float_frac = '.' uddigits;

sign = [+\-];
float_exp  = [eE] sign? uddigits;

float_number =
    int_number
    (
          float_exp
        | float_frac ( float_exp | ('r' >RationalSuffix)? )?
    )
    ('i' >ImaginarySuffix)?
;


### Character escapes

char_escape = '\\' (any - [CMcux0-7] - c_eof);

octal_escape = '\\' odigit{1,3};


### Unicode escapes

action InvalidUnicode
{
    throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "invalid Unicode escape");
}

action UnterminatedUnicode
{
    throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "unterminated Unicode escape");
}

unicode_digits = xdigit{1,6} >lerr(InvalidUnicode);

unicode_escape = '\\u' xdigit{4} @lerr(InvalidUnicode)
               | '\\u{' unicode_digits '}' @lerr(UnterminatedUnicode)
;


### Hexadecimal escape

action InvalidHex
{
    throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "invalid hex escape");
}

hex_escape   = '\\x' ( xdigit{1,2} >lerr InvalidHex );


### Control character escapes

action InvalidControl
{
    throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "Invalid escape character syntax");
}

ctrl_char = '\\' ( 'c' | 'C-' );
meta_char = '\\M-';

control_prefix = ctrl_char meta_char? | meta_char ctrl_char?;

control_escape = control_prefix (
      (ascii - '\\')
    | octal_escape
    | hex_escape
    | '\\' (ascii - [CMcux0-7])
) @lerr(InvalidControl);


### Identifiers

name = name_prefix name_char*;
constant = upper name_char*;
identifier = name - constant;

reserved =
      'alias'
    | 'and'
    | 'begin'
    | 'BEGIN'
    | 'break'
    | 'case'
    | 'class'
    | 'def'
    | 'defined?'
    | 'do'
    | 'else'
    | 'elsif'
    | 'end'
    | 'END'
    | 'ensure'
    | 'false'
    | 'for'
    | 'if'
    | 'in'
    | 'module'
    | 'next'
    | 'nil'
    | 'not'
    | 'or'
    | 'redo'
    | 'rescue'
    | 'retry'
    | 'return'
    | 'self'
    | 'super'
    | 'then'
    | 'true'
    | 'undef'
    | 'unless'
    | 'until'
    | 'when'
    | 'while'
    | 'yield'
    | '__ENCODING__'
    | '__FILE__'
    | '__LINE__'
;

percent_string_delimiter = ascii - alnum - c_eof;

beg_expressions =

    heredoc_identifier % {
        Lexer.EmitHeredocToken(ts, te);
        fbreak;
    }

    | '+' integer_number % {
        Lexer.EmitIntegerToken(ts, te, numBase, isRational, isImaginary);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    }

    | '+' float_number % {
        Lexer.EmitFloatToken(ts, te, isRational, isImaginary);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    }

    | '-' digit % {
        Lexer.EmitToken(kUMINUS_NUM, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    }

    | '-' ^(ws_nl | digit | [=>]) % {
        Lexer.EmitToken(kUMINUS, ts, te - 1);
        Lexer.CurrentState = Lexer.BegState;
        fhold;
        fbreak;
    }

    | '::' % {
        Lexer.EmitToken(kCOLON3, ts, te);
        Lexer.CurrentState = Lexer.BegState;
        fbreak;
    }

    | '%' [Qqxr] percent_string_delimiter % {
        Lexer.EmitStringToken(ts, te);
        fbreak;
    }

    | '%s' percent_string_delimiter % {
        Lexer.EmitStringToken(ts, te);
        Lexer.CurrentState = Lexer.FnameFitemState;
        fbreak;
    }

    | '%' [WwIi] percent_string_delimiter ws_nl* % {
        Lexer.EmitStringToken(ts, ts + 3);
        fbreak;
    }

    | '%' percent_string_delimiter % {
        Lexer.EmitStringToken(ts, te);
        fbreak;
    }

    | '%' [QqWwIixrs]? c_eof % {
        throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "unterminated quoted string meets end of file");
    }

    | '%' [QqWwIixrs]? (unicode | alnum) % {
        throw new SyntaxError(Lexer.Filename, Lexer.LineAt(ts), "unknown type of %string");
    }
;

}%%
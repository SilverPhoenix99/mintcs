%%{

# Character classes are in lowercase. e.g.: eof
# Machines/scanners are in uppercase. e.g.: EXPR_BEG
# Actions are in CamelCase. e.g.: DoEof

# The first state is BOF (beginning of file)

machine Lex;
access this.;
alphtype uint;
variable p this.p;
getkey Peek();

# ------------------------------------------------------------------------------
#
# Character Classes
#

action NewLine {
    // NewLine
    if(line_jump > this.p)
    {
        fexec line_jump;
    }
}

action TokStart { lts = this.p; }
action TokEnd   { lte = this.p; }

c_eof   = 0; # Lexer already excludes 0x4 and 0x1A (^D | ^Z)
nl      = '\n' @NewLine;
ws      = ( (space - nl) | ('\\' nl) ) %TokStart;
nl_eof  = nl | c_eof;
nl_ws   = nl | ws;
unicode = ^ascii;

ident_start = lower | '_' | unicode;
ident_char  = alnum | '_' | unicode;

string_term = [QqWwIixrs];


#-------------------------------------------------------------------------------
#
# Actions
#

action Keyword {
    // Keyword
    KeywordToken(token_type, lts, lte, next_state);
    fbreak;
}

action Number {
    GenNumberToken(token_type, num_base, num_flags, ts: lts >= 0 ? lts : ts);
    if(FcalledBy(false, COMMON_EXPR))
    {
        PopFcall();
    }
    fnext EXPR_END;
    fbreak;
}

action StringStart {
    // StringStart
    if(lte >= 0)
    {
        fexec te = lte;
    }
    GenLiteralToken(lts >= 0 ? lts : ts);
    if(cs != (int) COMMON_EXPR)
    {
        PushFcall(); // this is so that strings can identify who called them if needed
    }
    fnext *((int) literals.Peek().State);
    fbreak;
}


# ------------------------------------------------------------------------------
#
# Comments
#

# TODO: magic comments

line_comment = '#' ^nl_eof*;

action EmbDocEof { throw new SyntaxError(Location(p).Item1, "embedded document meets end of file"); }

block_trail = (space - nl) ^nl*;

block_comment =
    '=begin' block_trail? nl
    (
        (any* nl)*
        :>>
        '=end' block_trail? nl_eof
    ) @err(EmbDocEof)
;

# Expressions that must be at the beginning of a line.
bol = block_comment | '__END__' nl_eof;


# ------------------------------------------------------------------------------
#
# Numerics
#

# TODO: error => numeric literal without digits

action RacSuf { num_flags |= RATIONAL_FLAG; }
action CmxSuf { num_flags |= IMAGINARY_FLAG; }
action IntNum { token_type = tINTEGER; }
action FloNum { token_type = tFLOAT; }
action TrailError { throw new SyntaxError(Location(p).Item1, "trailing `_' in number"); }

bdigit = [01];
odigit = [0-7];

# digits with leading `_' like in 1_000_00
ubdigits = bdigit ( '_'? bdigit )* ('_' %TrailError)? ;
uodigits = odigit ( '_'? odigit )* ('_' %TrailError)? ;
uddigits =  digit ( '_'?  digit )* ('_' %TrailError)? ;
uxdigits = xdigit ( '_'? xdigit )* ('_' %TrailError)? ;

bin_number  =   '0' [bB]   ubdigits % { num_base =  2; };
oct_number  =   '0' [oO_]? uodigits % { num_base =  8; };
dec_number  =   '0' [dD]   uddigits % { num_base = 10; };
hex_number  =   '0' [xX]   uxdigits % { num_base = 16; };
int_number  = ( '0' | [1-9] ( '_'? digit )* ) ('_' %TrailError)? % { num_base = 10; };

sign = [+\-];

real_frac = '.' uddigits;
real_exp  = [eE] sign? uddigits;


real_number =
    int_number
    (
          real_exp
        | real_frac ( real_exp | ('r' %RacSuf)? )?
    ) %FloNum
;

rationable_number = (
      bin_number
    | oct_number
    | dec_number
    | hex_number
    | int_number
) %IntNum ('r' %RacSuf)? ;

number = ( rationable_number | real_number ) ('i' %CmxSuf)? ;


# ------------------------------------------------------------------------------
#
# Sign +/-
#

action UnaryOp {
    if(lts < 0)
    {
        lts = ts;
    }
    fexec te = lts + 1;
    GenToken(token_type, ts: lts);
    fnext EXPR_BEG;
    fbreak;
}

e_beg_sign =
      '+' %TokStart number %Number
    | (
          '+' [^=0-9]  % { token_type = kUPLUS; }
        | '-' [^=>0-9] % { token_type = kUMINUS; }
        | '-' digit    % { token_type = kUMINUS_NUM; }
    ) %UnaryOp
;

e_arg_sign =
    ws+ (
          '+' %TokStart number %Number
        | (
              '+' ^(space | [=0-9])  % { token_type = kUPLUS; }
            | '-' ^(space | [=>0-9]) % { token_type = kUMINUS; }
            | '-' digit % { token_type = kUMINUS_NUM; }
        ) %UnaryOp
    )
;


# ------------------------------------------------------------------------------
#
# Percent strings
#

# MRI accepts a unicode code byte as string initiator
# but then gives an error when trying to close,
# or if the unicode is invalid.
# In here, unicode is explicitly disabled.
percent_string = '%' string_term? (
    c_eof @{ throw new SyntaxError(Location(p).Item1, "unknown type of %string"); }
  | (ascii - alnum) @lerr{ throw new SyntaxError(Location(p).Item1, "unknown type of %string"); }
);


# ------------------------------------------------------------------------------
#
# Heredocs
#

action Heredoc {
  var lit = GenHeredocToken(lts >= 0 ? lts : ts);
  fexec lit.ContentStart = NextBOL();
  PushFcall();
  fnext HEREDOC_DELIMITER;
  fbreak;
}

action UnterminatedHeredoc { throw new SyntaxError(Location(p).Item1, "unterminated here document identifier"); }

# This is different from MRI: MRI accepts \n in identifiers,
# but then it can't find the identifier anywhere after. (MRI bug)
# In this case, \n isn't accepted in identifiers.
# There is no interpolation inside the identifier.
# Heredocs of type <<' have no interpolation in content.
heredoc_ident = '<<' [~\-]? (
    ident_char+
  | '"' ^('"' | nl_eof)* '"' @lerr(UnterminatedHeredoc)
  | "'" ^("'" | nl_eof)* "'" @lerr(UnterminatedHeredoc)
  | '`' ^('`' | nl_eof)* '`' @lerr(UnterminatedHeredoc)
);


# ------------------------------------------------------------------------------
#
# Identifiers
#

reserved_ident = 'alias'
               | 'and'
               | 'begin'
               | 'break'
               | 'case'
               | 'class'
               | 'def'
               | 'do'
               | 'else'
               | 'elsif'
               | 'end'
               | 'ensure'
               | 'false'
               | 'for'
               | 'if'
               | 'in'
               | 'module'
               | 'next'
               | 'nil'
               | 'not'
               | 'or'
               | 'redo'
               | 'rescue'
               | 'retry'
               | 'return'
               | 'self'
               | 'super'
               | 'then'
               | 'true'
               | 'undef'
               | 'unless'
               | 'until'
               | 'when'
               | 'while'
               | 'yield'
               | '__ENCODING__'
               | '__FILE__'
               | '__LINE__'
;

reserved_const = 'BEGIN' | 'END';
reserved_fid   = 'defined?' %TokEnd [^=];

reserved = ( reserved_ident | reserved_const | reserved_fid ) % { token_type = RESERVED; };

identifier  = ( (ident_start ident_char*) - reserved_ident ) % { token_type = tIDENTIFIER; };
constant    = ( (upper       ident_char*) - reserved_const ) % { token_type = tCONSTANT; };
fid         = ( ((ident_start | upper) ident_char*) - reserved_fid ) [?!] %TokEnd [^=] % { token_type = tFID; };
setter_name = ( ident_start | upper ) ident_char* '=' %TokEnd ( [^~=>] | '=>' ) % { token_type = tIDENTIFIER; };

any_ident   = identifier | constant | fid;

# don't put token_type = :tLABEL, because it may be refused if InCmd == true
label = (
    ( identifier | constant | reserved_ident | reserved_const ) ':'
  | (fid | reserved_fid) & (any+ ':')
) %TokEnd [^:];

bref_char = [&+``''];
back_ref  = '$' bref_char % { token_type = tBACK_REF; };

# TODO: if it doesn't fit a Fixnum, give warning.
#       See parse_numvar.
#       Don't give warning in EXPR_FNAME.
nth_ref  = '$' [1-9] digit* % { token_type = tNTH_REF; };

gvar_char = [~*$?!@/\\;,.=:<>""];

invalid_gvar = ^(
    ident_char
  | gvar_char
  | bref_char
  | space
  | c_eof
  | [1-9\-]
);

gvar = '$' (
    '-' ident_char
  | ( ident_char - [1-9] ) ident_char*
  | gvar_char
  | (space | c_eof) @ { throw new SyntaxError(Location(p).Item1, "`$' without identifiers is not allowed as a global variable name"); }
) >err {
    throw new SyntaxError(Location(p).Item1, $"`{CurrentToken()}' is not allowed as a global variable name");
  } % { token_type = tGVAR; };

var = (
    (ident_char - digit) ident_char*
  | ( digit | ^ident_char ) % {
      var tok = CurrentToken();
      var type_str = token_type == tIVAR ? "n instance" : " class";
      throw new SyntaxError(Location(p).Item1, $"`{tok}' is not allowed as a{type_str} variable name");
    }

  | ( c_eof | space ) % {
      var tok = CurrentToken(ote: -1);
      var type_str = token_type == tIVAR ? "n instance" : " class";
      var msg = $"`{tok}' without identifiers is not allowed as a{type_str} variable name";
      throw new SyntaxError(Location(p).Item1, msg);
    }
);

ivar = '@' % { token_type = tIVAR; } var;
cvar = '@@' % { token_type = tCVAR; } var;

any_var =
    back_ref
  | nth_ref
  | gvar
  | cvar
  | ivar
;

op_asgn = '&&='
        | '&='
        | '**='
        | '*='
        | '||='
        | '|='
        | '+='
        | '-='
        | '/='
        | '^='
        | '%='
        | '<<='
        | '>>='
;

# Expressions common to EXPR_DOT and EXPR_FNAME
operator_expr = (
    # same op as COMMON_EXPR
    '!=' | '!~' | '!'
  | '===' | '==' | '=~' | '=>' | '='
  | '<=>' | '<=' | '<'
  | '>=' | '>'
  | '~'

    # similar to COMMON_EXPR
  | '**' %TokEnd [^=]   % { token_type = OPERATORS; }
  | '*'  %TokEnd [^=]   % { token_type = OPERATORS; }
  | '+'  %TokEnd [^=]   % { token_type = OPERATORS; }
  | '-'  %TokEnd [^=]   % { token_type = OPERATORS; }
  | '&'  %TokEnd [^&.=] % { token_type = OPERATORS; }
  | '<<' %TokEnd [^=]
  | '>>' %TokEnd [^=]
  | '|'  %TokEnd [^|=]
  | '/'  %TokEnd [^=]
  | '^'  %TokEnd [^=]
  | '%'  %TokEnd [^=]
  | '[' % { token_type = OPERATORS; }

    # unique to operator_expr
  | '+@' | '-@' | '!@' | '~@'
  | '[]' | '[]='
) % { next_state = EXPR_ARG; };


#
# Machines #####################################################################
#


#
# Main/Entry - Beginning of File  ----------------------------------------------
#

action RetryBeg {
    fexec 0;
    fgoto EXPR_BEG;
}

action GotoBeg {
    lts = -1;
    fgoto EXPR_BEG;
}

BOF := bol @err(RetryBeg) @GotoBeg;

empty_lines = nl bol? (ws* nl bol?)* % { lts = -1; };


#
# Expressions ------------------------------------------------------------------
# Expressions are not callable.
# They are transitioned to through fnext or fgoto.

EXPR_BEG := |*

  empty_lines;

  e_beg_sign;

  '/' => StringStart;

  percent_string => StringStart;

  heredoc_ident => Heredoc;

  (
      '::'
    | ( '**' | '*' ) %TokEnd [^=]
    | '&' %TokEnd [^&.=]
    | '('
    | '['
    | label % {
        if(InCmd)
        {
          // label not allowed
          lte -= 1; // remove trailing ':'
          if(token_type != KEYWORDS)
          {
            next_state = EXPR_CMDARG;
          }
        }
        else
        {
          token_type = tLABEL;
          next_state = EXPR_LABELARG;
        }
      }
    | reserved  % { next_state = null; }
    | any_ident % { next_state = InCmd ? EXPR_CMDARG : EXPR_ARG; }

  ) => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


EXPR_ARG := |*
  # TODO: EXPR_ARG is always accepting EXPR_LABEL. Verify when not to allow EXPR_LABEL with EXPR_ARG

  ws+ heredoc_ident => Heredoc;

  e_arg_sign;

  ws+ '/' %TokEnd ^(space | '=') => StringStart;

  ws+ percent_string - (any* '=') => StringStart;

  ws+ '::' => Keyword;

  ws+ ( '**' | '*' ) %TokEnd ^(space | '=') => Keyword;

  ws+ '&' %TokEnd ^(space | [&.=]) => Keyword;

  # exclude '?\\\n': it resolves to '\n' as if '?\\n'
  '?' %TokEnd space => Keyword;

  ws+ '(' % { token_type = kLPAREN_ARG; } => Keyword;

  ws+ '[' => Keyword;

  '{' % {
    if(LParBeg > 0 && LParBeg == ParenNest)
    {
      LParBeg = 0;
      ParenNest -= 1;
      token_type = kLAMBEG;
    }
    else
    {
      InCmd = true;
      token_type = OPERATORS;
    }
  } => Keyword;

  label % { token_type = tLABEL; next_state = EXPR_LABELARG; } => Keyword;

  reserved % { next_state = null; } => Keyword;

  any_ident % { next_state = InCmd ? EXPR_CMDARG : EXPR_ARG; } => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


EXPR_CLASS := |*

  empty_lines;

  e_beg_sign;

  '/' => StringStart;

  percent_string => StringStart;

  (
      '::'
    | ( '**' | '*' ) %TokEnd [^=]
    | ( '<=>' | '<=' | '<' | '<<' %TokEnd [^=] ) % { InCmd = true; }
    | '&' %TokEnd [^&.=]
    | '('
    | '['
    | reserved  % { next_state = null; }
    | any_ident % { next_state = InCmd ? EXPR_CMDARG : EXPR_ARG; }

  ) => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


EXPR_CMDARG := |*

  e_arg_sign;

  ws+ '/' %TokEnd ^(space | '=') => StringStart;

  ws+ percent_string - '%=' => StringStart;

  ws+ heredoc_ident => Heredoc;

  ws+ '::' => Keyword;

  ws+ ( '**' | '*' ) %TokEnd ^(space | '=') => Keyword;

  ws+ '&' %TokEnd ^(space | [&.=]) => Keyword;

  # exclude '?\\\n': it resolves to '\n' as if '?\\n'
  '?' %TokEnd space => Keyword;

  ws+ '(' % { token_type = kLPAREN_ARG; } => Keyword;

  ws+ '[' => Keyword;

  '{' % {
    if(LParBeg > 0 && LParBeg == ParenNest)
    {
      LParBeg = 0;
      ParenNest--;
      token_type = kLAMBEG;
    }
    else
    {
      InCmd = true;
      token_type = OPERATORS;
    }
  } => Keyword;

  label % { token_type = tLABEL; next_state = EXPR_LABELARG; } => Keyword;

  reserved % { next_state = null; } => Keyword;

  any_ident % { next_state = InCmd ? EXPR_CMDARG : EXPR_ARG; } => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


EXPR_DOT := |*

  empty_lines;

  operator_expr => Keyword;

  '`' % { next_state = InCmd ? EXPR_CMDARG : EXPR_ARG; } => Keyword;

  (
      any_ident
    | reserved_ident % { token_type = tIDENTIFIER; }
    | reserved_const % { token_type = tCONSTANT; }
    | reserved_fid   % { token_type = tFID; }
  ) % { next_state = InCmd ? EXPR_CMDARG : EXPR_ARG; } => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


EXPR_END := |*

  ':' %TokEnd [^:] => Keyword;

  '?' => Keyword;

  '{' % {
    if(LParBeg > 0 && LParBeg == ParenNest)
    {
      LParBeg = 0;
      ParenNest--;
      token_type = kLAMBEG;
    }
    else
    {
      InCmd = true;
      token_type = OPERATORS;
    }
  } => Keyword;

  reserved % { next_state = null; } => Keyword;

  any_ident % { next_state = EXPR_END; } => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


EXPR_ENDARG := |*

  ':' %TokEnd [^:] => Keyword;

  '?' => Keyword;

  '{' % {
    if(LParBeg > 0 && LParBeg == ParenNest)
    {
      LParBeg = 0;
      ParenNest--;
      token_type = kLAMBEG;
    }
    else
    {
      InCmd = true;
      token_type = kLBRACE_ARG;
    }
  } => Keyword;

  reserved % { next_state = null; } => Keyword;

  any_ident % { next_state = EXPR_END; } => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


EXPR_ENDFN := |*

  ':' %TokEnd [^:] => Keyword;

  '?' => Keyword;

  '{' % {
    if(LParBeg > 0 && LParBeg == ParenNest)
    {
      LParBeg = 0;
      ParenNest--;
      token_type = kLAMBEG;
    }
    else
    {
      InCmd = true;
      token_type = OPERATORS;
    }
  } => Keyword;

  label % {
    if(InCmd)
    {
      // label not allowed
      lte -= 1; // remove trailing ':'
      if(token_type != KEYWORDS)
      {
        next_state = EXPR_CMDARG;
      }
    }
    else
    {
      token_type = tLABEL;
      next_state = EXPR_LABELARG;
    }
  } => Keyword;

  reserved  % { next_state = null; } => Keyword;
  any_ident % { next_state = EXPR_ENDFN; } => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


EXPR_FNAME := |*

  empty_lines;

  heredoc_ident => Heredoc;

  back_ref | nth_ref => {
    GenToken(tGVAR);
    fnext EXPR_END;
    fbreak;
  };

  (
      operator_expr
    | '`'       % { next_state = EXPR_ENDFN; }
    | reserved  % { next_state = EXPR_ENDFN; }
    | any_ident % { next_state = EXPR_ENDFN; }
  ) => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


# Equivalent to EXPR_ARG|EXPR_LABELED in MRI.
EXPR_LABELARG := |*

  empty_lines => {
    if(InKwarg)
    {
      InCmd = true;
      GenToken(kNL, token: "\n");
      fnext EXPR_BEG;
      fbreak;
    }
  };

  heredoc_ident => Heredoc;

  e_beg_sign;

  '/' => StringStart;

  percent_string => StringStart;

  '::' => Keyword;

  ( '**' | '*' ) %TokEnd [^=] => Keyword;

  '&' %TokEnd [^&.=] => Keyword;

  # exclude '?\\\n': it resolves to '\n' as if '?\\n'
  '?' %TokEnd space => Keyword;

  '(' => Keyword;

  '[' => Keyword;

  label % { token_type = tLABEL; next_state = EXPR_LABELARG; } => Keyword;

  reserved % { next_state = null; } => Keyword;

  any_ident % { next_state = InCmd ? EXPR_CMDARG : EXPR_ARG; } => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


EXPR_MID := |*

  e_beg_sign;

  heredoc_ident => Heredoc;

  '/' => StringStart;

  percent_string => StringStart;

  '::' => Keyword;

  ( '**' | '*' ) %TokEnd [^=] => Keyword;

  '&' %TokEnd [^&.=] => Keyword;

  '(' => Keyword;

  '[' => Keyword;

  reserved % { next_state = null; } => Keyword;

  any_ident % { next_state = InCmd ? EXPR_CMDARG : EXPR_ARG; } => Keyword;

  any => { fhold; fcall COMMON_EXPR; };

*|;


# ------------------------------------------------------------------------------
#
# Shared expressions
# (i.e., expressions that can exist anywhere)
#

COMMON_EXPR := |*
  c_eof;

  # ignore and continue parsing in corresponding expression state
  ws+ => {
      lts = -1;
      fret;
  };

  line_comment; # no op

  empty_lines => {
    InCmd = true;
    GenToken(kNL, token: "\n");
    PopFcall();
    fnext EXPR_BEG;
    fbreak;
  };

  # ---

      # same op as operator_expr
      '!=' | '!~' | '!'
    | '===' | '==' | '=~' | '=>' | '='
    | '<=>' | '<=' | '<'
    | '>=' | '>'
    | '~'

    | '<<' | '>>' | '|' | '/' | '^' | '%'
    | '...' | '..' | ',' | '&&' | '||'

    | ( '**' | '*' | '+' | '-' | '&' %TokEnd [^.] ) % { token_type = OPERATORS; }
    | op_asgn % { token_type = OPERATORS; }
    | (
          nl %TokStart ws* '.' %TokEnd [^.0-9]
        | nl %TokStart ws* '&.'
        | '.'
        | '&.'
        | '::' % { token_type = OPERATORS; }
      ) % { next_state = EXPR_DOT; }

    | ';' % { InCmd = true; }

    | ':' %TokEnd ( space | '#' )

    | ':' % { token_type = tSYMBEG; next_state = EXPR_FNAME; }

    | '->' % { next_state = EXPR_ENDFN; }

    | '(' % { token_type = OPERATORS; }
    | ')' % { next_state = EXPR_ENDFN; }
    | '[' % { token_type = OPERATORS; }
    | ']' % { next_state = EXPR_ENDARG; }

    | '}'

    | '{' % {
        if(LParBeg > 0 && LParBeg == ParenNest)
        {
          LParBeg = 0;
          ParenNest--;
          token_type = kLAMBEG;
        }
      }

    | any_var % { next_state = EXPR_END; }

    | '?' %TokEnd (

        (alnum | '_') ident_char

        # exclude '?\\\n': it resolves to '\n' as if '?\\n'
      | space % {
          var c = CurrentToken(ots: 1, ote: 1)[0];
          var i = " \n\f\r\t\v".IndexOf(c);
          c = "snfrtv"[i];
          Console.WriteLine($"invalid character syntax; use ?\\{c}");
        }

      | c_eof % { throw new SyntaxError(Location(p).Item1, "incomplete character syntax"); }

    )

  => Keyword;

  # ---

  '?' => {
    PopFcall();
    fgoto CHAR;
  };

  [''""``] | ':' [''""] => StringStart;

  number => Number;

  '.' digit => { throw new SyntaxError(Location(p).Item1, "no .<digit> floating literal anymore; put 0 before dot"); };

  ^ident_char => {
    throw new SyntaxError(Location(p).Item1, $"Invalid char `{CurrentToken()}' in expression at {ts}");
  };

  any => { throw new SyntaxError(Location(p).Item1, $"Don't know what to do with `{CurrentToken()}' at {ts}"); };

*|;


# ##############################################################################
#
# Strings: <<Heredocs, 'strings', %w(words) and ?chars
#

action EofLiteralError { throw new SyntaxError(Location(p).Item1, current_literal.UnterminatedMessage); }


# ------------------------------------------------------------------------------
#
# Character escaping
#

action InvalidUnicode { throw new SyntaxError(Location(p).Item1, "invalid Unicode escape"); }
action UntermUnicode  { throw new SyntaxError(Location(p).Item1, "unterminated Unicode escape"); }

unicode_digits = xdigit{1,6} >lerr(InvalidUnicode);

unicode_escape = '\\u' xdigit{4} @lerr(InvalidUnicode)
               | '\\u{' unicode_digits '}' @lerr(UntermUnicode)
;

multi_unicode_escape = '\\u' xdigit{4} @lerr(InvalidUnicode)
                     | '\\u{' unicode_digits ([\t ] @lerr(UntermUnicode) unicode_digits)* '}' @lerr(UntermUnicode)
;

char_escape = '\\' (ascii - [CMcux0-7] - c_eof);

octal_escape = '\\' odigit{1,3};


action InvalidHex { throw new SyntaxError(Location(p).Item1, "invalid hex escape"); }

hex_escape   = '\\x' ( xdigit{1,2} >lerr InvalidHex );


action InvalidControl { throw new SyntaxError(Location(p).Item1, "Invalid escape character syntax"); }

ctrl_char = '\\' ( 'c' | 'C-' );
meta_char = '\\M-';

control_prefix = ctrl_char meta_char? | meta_char ctrl_char?;

control_escape = control_prefix (
    (ascii - '\\')
  | octal_escape
  | hex_escape
  | '\\' (ascii - [CMcux0-7])
) @lerr(InvalidControl);


# ------------------------------------------------------------------------------
#
# Heredocs
#

# Heredoc existence condition:
#     ( cs in (EXPR_BEG, EXPR_FNAME, EXPR_LABELARG, EXPR_MID) )
#  || ( cs in (EXPR_ARG, EXPR_CMDARG) && ( ts == 0 || Data[ts - 1].Matches(" \f\t\r\v") ) )

HEREDOC_DELIMITER := |*
    c_eof => EofLiteralError;

    ^nl_eof* nl_eof => {
        if(current_literal.IsDelimiter(CurrentToken()))
        {
            // found delimiter => end of heredoc
            GenStringContentToken();
            GenStringEndToken();
            line_jump = te;
            fexec ((Heredoc) current_literal).Restore;
            PopFcall();
            fnext EXPR_END;
            fbreak;
        }

        fexec ts;
        fgoto HEREDOC_CONTENT;
    };

*|;

HEREDOC_CONTENT := |*
    # TODO: '\\\n' - counts as not being present, if id_delimiter != "'"

    c_eof => EofLiteralError;

    '\n' => { // don't jump yet
        current_literal.LineIndent = 0;

        if(line_jump > this.p)
        {
            // content in te..line_jump isn't included
            GenStringContentToken(0);
            current_literal.ContentStart = line_jump;
            fexec line_jump;
        }

        fgoto HEREDOC_DELIMITER;
    };

    '\\' ^c_eof => { current_literal.CommitIndent(); };

    '#' any_var => { GenInterpolationTokens(token_type); };

    '#{' => {
        current_literal.CommitIndent();
        if(current_literal.Interpolates)
        {
            GenStringContentToken();
            GenToken(tSTRING_DBEG);
            fnext EXPR_BEG;
            fbreak;
        }
    };

    ' ' => {
        if(current_literal.Dedents && current_literal.LineIndent >= 0)
        {
            current_literal.LineIndent++;
        }
    };

    '\t' => {
        if(current_literal.Dedents && current_literal.LineIndent >= 0)
        {
            var w = current_literal.LineIndent / TabWidth + 1;
            current_literal.LineIndent = w * TabWidth;
        }
    };

    any => { current_literal.CommitIndent(); };

*|;


# ------------------------------------------------------------------------------
#
# Strings
#

# ^D (0x4) isn't used by the lexer.
# The real string delimiter is replaced by ^D to generalize STRING_CONTENT.
string_delimiter = 0x4;


action StringDelimiter {
    GenStringContentToken();

    if(current_literal.IsDelimiter("\n") && line_jump > this.p)
    {
        fexec te = line_jump;
        ts = p;
    }

    if(current_literal.IsRegexp)
    {
        regexp_delim = ts;
        regex_options = 0;
        fgoto REGEXP_END;
    }

    var is_labeled = (Peek(1) == ':' && Peek(2) != ':')
        && current_literal.CanLabel
        && (
               FcalledBy(EXPR_ARG, EXPR_CMDARG, EXPR_LABELARG) ||
               (!Cond.Peek && FcalledBy(EXPR_BEG, EXPR_ENDFN))
           );

    if(is_labeled)
    {
        // grab ':'
        fexec te + 1;
        fnext EXPR_BEG;
    }
    else
    {
        fnext EXPR_END;
    }

    GenStringEndToken();
    fbreak;
}


action StringDBeg {
    if(current_literal.Interpolates)
    {
        GenStringContentToken();
        GenToken(tSTRING_DBEG);
        PopFcall();
        fnext EXPR_BEG;
        fbreak;
    }
}


action StringDVar { GenInterpolationTokens(token_type); }


action StringNl {
    if(line_jump > 0)
    {
        // content in te...line_jump isn't included
        lte = current_literal.State == WORD_CONTENT && Peek(ts) == '\\' ? -1 : 0;
        GenStringContentToken();
        current_literal.ContentStart = line_jump;
        fexec line_jump;
    }
}


STRING_CONTENT :=
    (
        c_eof @EofLiteralError
      | octal_escape
      | hex_escape
      | char_escape
      | multi_unicode_escape
      | control_escape
      | '\\'? '\n'  %StringNl
      | '#{'        %StringDBeg
      | '#' any_var %StringDVar
      | ^([\\\n] | c_eof | string_delimiter)
    )*
    string_delimiter @StringDelimiter
;


# ts...lte : tSTRING_CONTENT
# lte...te : tSPACE
action WordContent {
    if(GenStringContentToken(lte - te) != null)
    {
        GenToken(tSPACE, ts: lte);
        fbreak;
    }
}


WORD_CONTENT :=
    (space | nl)*
    (
        (
            c_eof @EofLiteralError
          | octal_escape
          | hex_escape
          | char_escape
          | multi_unicode_escape
          | control_escape
          | '\\'? '\n'  %StringNl
          | '#{'        %StringDBeg
          | '#' any_var %StringDVar
          | ^([\\\n] | c_eof | string_delimiter | space)
        )+ > { current_literal.ContentStart = p; } %TokEnd
        (space - nl)* %WordContent
    )?
    string_delimiter %StringDelimiter
;


REGEXP_END := |*

  'm' => { regex_options |= Regexp.Flags.Multiline; };
  'i' => { regex_options |= Regexp.Flags.IgnoreCase; };
  'x' => { regex_options |= Regexp.Flags.Extend; };
  'o' => { regex_options |= Regexp.Flags.Once; };

  ( alpha - [mixo] )+ => {
    var tok = CurrentToken();
    var opt = tok.Length == 1 ? "" : "s";
    throw new SyntaxError(Location(p).Item1, $"unknown regexp option{opt} - {tok}");
  };

  ^alpha => {
    fexec te -= 1;
    var tok = GenToken(tREGEXP_END, ts: regexp_delim);
    tok.Properties["flags"] = regex_options;
    fnext EXPR_END;
    fbreak;
  };

*|;


# ------------------------------------------------------------------------------
#
# Single characters (e.g.: ?a)
#

CHAR := |*
  c_eof => { throw new SyntaxError(Location(p).Item1, "incomplete character syntax"); };

    unicode_escape
  | octal_escape
  | hex_escape
  | char_escape
  | control_escape
  | ^c_eof
  => {
    GenToken(tCHAR);
    fnext EXPR_END;
    fbreak;
  };

*|;


}%%